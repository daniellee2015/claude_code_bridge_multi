#!/usr/bin/env python3
"""
CCB Cleanup - Clean up zombie daemons and stale files
"""
import json
import os
import sys
from pathlib import Path


def is_pid_alive(pid: int) -> bool:
    """Check if a process is alive."""
    if pid <= 0:
        return False
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False


def cleanup_stale_state_files():
    """Remove state files for dead daemons."""
    cache_dir = Path.home() / ".cache" / "ccb" / "projects"
    if not cache_dir.exists():
        return

    removed = []
    for state_file in cache_dir.glob("*/askd.json"):
        try:
            with open(state_file) as f:
                data = json.load(f)
            pid = int(data.get("pid", 0))
            if pid > 0 and not is_pid_alive(pid):
                state_file.unlink()
                removed.append(str(state_file))
                print(f"Removed stale state file: {state_file}")
        except Exception as e:
            print(f"Error processing {state_file}: {e}", file=sys.stderr)

    return removed


def cleanup_stale_locks():
    """Remove stale lock files."""
    run_dir = Path.home() / ".ccb" / "run"
    if not run_dir.exists():
        return

    removed = []
    for lock_file in run_dir.glob("*.lock"):
        try:
            # Read PID from lock file
            pid_str = lock_file.read_text().strip()
            if not pid_str:
                continue
            pid = int(pid_str)
            if not is_pid_alive(pid):
                lock_file.unlink()
                removed.append(str(lock_file))
                print(f"Removed stale lock: {lock_file.name}")
        except Exception as e:
            print(f"Error processing {lock_file}: {e}", file=sys.stderr)

    return removed


def get_tmux_pane_for_workdir(work_dir: str) -> str:
    """Find tmux pane ID for a given work directory."""
    try:
        import subprocess
        result = subprocess.run(
            ["tmux", "list-panes", "-a", "-F", "#{pane_id}\t#{pane_current_path}"],
            capture_output=True,
            text=True,
            timeout=2.0
        )
        if result.returncode == 0:
            for line in result.stdout.strip().split('\n'):
                if '\t' in line:
                    pane_id, pane_path = line.split('\t', 1)
                    if pane_path == work_dir:
                        return pane_id
    except Exception:
        pass
    return "unknown"


def list_running_daemons(verbose=False):
    """List all running askd daemons."""
    cache_dir = Path.home() / ".cache" / "ccb" / "projects"
    if not cache_dir.exists():
        return []

    daemons = []
    for state_file in cache_dir.glob("*/askd.json"):
        try:
            with open(state_file) as f:
                data = json.load(f)
            pid = int(data.get("pid", 0))
            parent_pid = int(data.get("parent_pid", 0))

            if pid > 0 and is_pid_alive(pid):
                parent_alive = is_pid_alive(parent_pid) if parent_pid > 0 else False
                project_hash = state_file.parent.name
                daemon_info = {
                    "pid": pid,
                    "parent_pid": parent_pid,
                    "parent_alive": parent_alive,
                    "project_hash": project_hash,
                    "started_at": data.get("started_at", "unknown"),
                }

                if verbose:
                    daemon_info.update({
                        "work_dir": data.get("work_dir", "unknown"),
                        "port": data.get("port", "unknown"),
                        "host": data.get("host", "unknown"),
                        "managed": data.get("managed", False),
                        "tmux_pane": get_tmux_pane_for_workdir(data.get("work_dir", "")),
                    })

                daemons.append(daemon_info)
        except Exception:
            pass

    return daemons


def kill_daemon_by_pid(pid: int) -> bool:
    """Kill a specific daemon by PID."""
    if not is_pid_alive(pid):
        print(f"PID {pid} is not running", file=sys.stderr)
        return False

    try:
        os.kill(pid, 15)  # SIGTERM
        print(f"✅ Killed daemon PID {pid}")
        return True
    except Exception as e:
        print(f"❌ Failed to kill PID {pid}: {e}", file=sys.stderr)
        return False


def interactive_kill():
    """Interactive mode to select and kill daemons."""
    daemons = list_running_daemons(verbose=True)
    if not daemons:
        print("No running daemons found")
        return

    print("=== Running askd daemons ===\n")
    for idx, d in enumerate(daemons, 1):
        status = "ZOMBIE (parent dead)" if not d["parent_alive"] else "OK"
        tmux_pane = d.get('tmux_pane', 'unknown')
        print(f"{idx}. PID {d['pid']} (parent {d['parent_pid']}) - {status}")
        print(f"   Tmux Pane: {tmux_pane}")
        print(f"   Project: {d['project_hash']}")
        print(f"   Work Dir: {d.get('work_dir', 'unknown')}")
        print(f"   Started: {d['started_at']}")
        print()

    try:
        choice = input("Enter daemon number to kill (or 'q' to quit): ").strip()
        if choice.lower() == 'q':
            print("Cancelled")
            return

        idx = int(choice)
        if 1 <= idx <= len(daemons):
            daemon = daemons[idx - 1]
            confirm = input(f"Kill PID {daemon['pid']}? (y/N): ").strip().lower()
            if confirm == 'y':
                kill_daemon_by_pid(daemon['pid'])
            else:
                print("Cancelled")
        else:
            print(f"Invalid choice: {idx}", file=sys.stderr)
    except (ValueError, KeyboardInterrupt):
        print("\nCancelled")


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Clean up CCB zombie daemons and stale files")
    parser.add_argument("--list", action="store_true", help="List running daemons")
    parser.add_argument("-v", "--verbose", action="store_true", help="Show detailed daemon info")
    parser.add_argument("--clean", action="store_true", help="Clean stale files")
    parser.add_argument("--kill-zombies", action="store_true", help="Kill zombie daemons (parent dead)")
    parser.add_argument("--kill-pid", type=int, metavar="PID", help="Kill specific daemon by PID")
    parser.add_argument("-i", "--interactive", action="store_true", help="Interactive mode to select daemon to kill")

    args = parser.parse_args()

    # Interactive mode
    if args.interactive:
        interactive_kill()
        return

    # Kill specific PID
    if args.kill_pid:
        kill_daemon_by_pid(args.kill_pid)
        return

    # List daemons
    if args.list or not (args.clean or args.kill_zombies):
        print("=== Running askd daemons ===")
        daemons = list_running_daemons(verbose=args.verbose)
        if not daemons:
            print("No running daemons found")
        else:
            for d in daemons:
                status = "ZOMBIE (parent dead)" if not d["parent_alive"] else "OK"
                print(f"  PID {d['pid']} (parent {d['parent_pid']}) - {status}")
                print(f"    Project: {d['project_hash']}")
                print(f"    Started: {d['started_at']}")
                if args.verbose:
                    print(f"    Work Dir: {d.get('work_dir', 'unknown')}")
                    print(f"    Port: {d.get('port', 'unknown')}")
                    print(f"    Host: {d.get('host', 'unknown')}")
                    print(f"    Managed: {d.get('managed', False)}")
                    tmux_pane = d.get('tmux_pane', 'unknown')
                    print(f"    Tmux Pane: {tmux_pane}")

    if args.clean:
        print("\n=== Cleaning stale files ===")
        cleanup_stale_state_files()
        cleanup_stale_locks()

    if args.kill_zombies:
        print("\n=== Killing zombie daemons ===")
        daemons = list_running_daemons()
        for d in daemons:
            if not d["parent_alive"]:
                try:
                    os.kill(d["pid"], 15)  # SIGTERM
                    print(f"Killed zombie daemon PID {d['pid']}")
                except Exception as e:
                    print(f"Failed to kill PID {d['pid']}: {e}", file=sys.stderr)


if __name__ == "__main__":
    main()
