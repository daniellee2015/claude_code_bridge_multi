#!/usr/bin/env python3
"""
ccb-ping - Test connectivity with AI providers.

Usage:
    ccb-ping <provider> [--session-file FILE] [--autostart]

Providers:
    gemini, codex, opencode, droid, claude
"""

import sys
import os
import argparse
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import setup_windows_encoding
setup_windows_encoding()


# Provider to communicator module and class mapping
PROVIDER_COMMS = {
    "gemini": ("gemini_comm", "GeminiCommunicator"),
    "codex": ("codex_comm", "CodexCommunicator"),
    "opencode": ("opencode_comm", "OpenCodeCommunicator"),
    "droid": ("droid_comm", "DroidCommunicator"),
    "claude": ("claude_comm", "ClaudeCommunicator"),
}

def _usage():
    print("Usage: ccb-ping <provider> [--session-file FILE] [--autostart]", file=sys.stderr)
    print("", file=sys.stderr)
    print("Providers:", file=sys.stderr)
    print("  gemini, codex, opencode, droid, claude", file=sys.stderr)


def _resolve_work_dir(session_file: str | None) -> Path:
    if not session_file:
        return Path.cwd()
    raw = str(session_file).strip()
    if not raw:
        return Path.cwd()
    try:
        p = Path(os.path.expanduser(raw)).resolve()
    except Exception:
        p = Path(os.path.expanduser(raw)).absolute()
    # Session files normally live in <project>/.ccb/.<provider>-session
    parent_name = p.parent.name
    if parent_name in (".ccb", ".ccb_config"):
        return p.parent.parent
    return p.parent


def main():
    if len(sys.argv) < 2:
        _usage()
        return 1

    provider = sys.argv[1].lower()

    if provider in ("-h", "--help"):
        _usage()
        return 0

    if provider not in PROVIDER_COMMS:
        print(f"[ERROR] Unknown provider: {provider}", file=sys.stderr)
        print(f"[ERROR] Available: {', '.join(PROVIDER_COMMS.keys())}", file=sys.stderr)
        return 1

    # Parse remaining arguments
    parser = argparse.ArgumentParser(prog=f"ccb-ping {provider}", add_help=False)
    parser.add_argument("--session-file", dest="session_file", default=None)
    parser.add_argument("--autostart", action="store_true", help="Start daemon if needed")
    args, _ = parser.parse_known_args(sys.argv[2:])

    if args.session_file:
        os.environ["CCB_SESSION_FILE"] = str(args.session_file)
    work_dir = _resolve_work_dir(args.session_file)

    # Import and instantiate the communicator
    module_name, class_name = PROVIDER_COMMS[provider]
    try:
        module = __import__(module_name)
        comm_class = getattr(module, class_name)

        # Pre-emptive autostart check if requested
        if args.autostart:
            try:
                from askd_client import maybe_start_daemon, wait_for_daemon_ready
                from providers import (
                    CASK_CLIENT_SPEC,
                    DASK_CLIENT_SPEC,
                    GASK_CLIENT_SPEC,
                    LASK_CLIENT_SPEC,
                    OASK_CLIENT_SPEC,
                )

                specs = {
                    "codex": CASK_CLIENT_SPEC,
                    "gemini": GASK_CLIENT_SPEC,
                    "opencode": OASK_CLIENT_SPEC,
                    "claude": LASK_CLIENT_SPEC,
                    "droid": DASK_CLIENT_SPEC,
                }

                spec = specs.get(provider)
                if spec:
                    maybe_start_daemon(spec, work_dir)
                    # Small wait for it to bind
                    wait_for_daemon_ready(spec, 0.5)
            except Exception as e:
                print(f"[WARN] Autostart pre-check failed: {e}", file=sys.stderr)

        comm = comm_class()
        healthy, message = comm.ping(display=False)
        print(message)
        return 0 if healthy else 1
    except ImportError as e:
        print(f"[ERROR] Module import failed: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"[ERROR] {provider.capitalize()} connectivity test failed: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
