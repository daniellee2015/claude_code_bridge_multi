#!/usr/bin/env python3
"""
CCB Completion Hook - Notifies caller when a CCB delegation task completes.

This script is called by caskd/gaskd/oaskd/daskd when they detect CCB_DONE signal.
- For terminal callers: sends notification to Claude/Codex/Droid pane
- For email callers (CCB_CALLER=email): sends reply email via maild

Usage:
    ccb-completion-hook.py --provider <provider> --output <output_file> [--reply <reply_text>]

Environment:
    CCB_COMPLETION_HOOK_ENABLED: Set to "0" to disable (default: "1")
    CCB_COMPLETION_HOOK_TIMEOUT: Timeout in seconds (default: 5)
    CCB_CALLER: Who initiated the request (claude/codex/droid/email)
    CCB_EMAIL_REQ_ID: Request ID for email replies
    CCB_EMAIL_MSG_ID: Original email Message-ID for threading
    CCB_EMAIL_FROM: Original sender email address
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path

# Add lib directory to path for imports
script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding

setup_windows_encoding()


def env_bool(name: str, default: bool = True) -> bool:
    val = os.environ.get(name, "").strip().lower()
    if not val:
        return default
    return val not in ("0", "false", "no", "off")


def env_float(name: str, default: float) -> float:
    val = os.environ.get(name, "").strip()
    if not val:
        return default
    try:
        return float(val)
    except ValueError:
        return default


def load_session_file(session_path: Path) -> dict:
    """Load session file with utf-8-sig encoding (handles BOM from PowerShell)."""
    try:
        with open(session_path, encoding="utf-8-sig") as f:
            return json.load(f)
    except Exception:
        return {}


def send_via_terminal(pane_id: str, message: str, terminal: str, session_data: dict) -> bool:
    """Send message via terminal backend (tmux or wezterm)."""
    if terminal == "wezterm":
        return send_via_wezterm(pane_id, message, session_data)
    else:
        return send_via_tmux(pane_id, message)


def find_wezterm_cli() -> str | None:
    """Find wezterm CLI executable."""
    import shutil
    # Check environment variable first
    wezterm_bin = os.environ.get("CCB_WEZTERM_BIN", "").strip()
    if wezterm_bin and Path(wezterm_bin).exists():
        return wezterm_bin
    # Try shutil.which for PATH lookup
    found = shutil.which("wezterm")
    if found:
        return found
    # Common Windows locations
    if os.name == "nt":
        common_paths = [
            Path(os.environ.get("PROGRAMFILES", "")) / "WezTerm" / "wezterm.exe",
            Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "WezTerm" / "wezterm.exe",
            Path.home() / "scoop" / "apps" / "wezterm" / "current" / "wezterm.exe",
        ]
        for p in common_paths:
            if p.exists():
                return str(p)
    return None


def send_via_wezterm(pane_id: str, message: str, session_data: dict) -> bool:
    """Send message to WezTerm pane using wezterm cli with stdin for large payloads."""
    try:
        wezterm = find_wezterm_cli()
        if not wezterm:
            return False

        # Use stdin to avoid command line length limits on Windows
        # wezterm cli send-text --pane-id <id> --no-paste reads from stdin if no text arg
        result = subprocess.run(
            [wezterm, "cli", "send-text", "--pane-id", pane_id, "--no-paste"],
            input=message.encode("utf-8"),
            capture_output=True,
            timeout=10
        )
        if result.returncode == 0:
            # Send Enter after text
            subprocess.run(
                [wezterm, "cli", "send-text", "--pane-id", pane_id, "--no-paste"],
                input=b"\r",
                capture_output=True,
                timeout=5
            )
            return True
    except Exception:
        pass
    return False


def send_via_tmux(pane_id: str, message: str) -> bool:
    """Send message to tmux pane using load-buffer + paste-buffer."""
    try:
        import time

        # Ensure pane is not in copy mode
        try:
            mode_result = subprocess.run(
                ["tmux", "display-message", "-p", "-t", pane_id, "#{pane_in_mode}"],
                capture_output=True,
                text=True,
                timeout=2
            )
            if mode_result.returncode == 0 and mode_result.stdout.strip() in ("1", "on", "yes"):
                subprocess.run(
                    ["tmux", "send-keys", "-t", pane_id, "-X", "cancel"],
                    capture_output=True,
                    timeout=2
                )
        except Exception:
            pass

        buffer_name = f"ccb-hook-{os.getpid()}-{int(time.time() * 1000)}"
        # Load message into tmux buffer
        load_result = subprocess.run(
            ["tmux", "load-buffer", "-b", buffer_name, "-"],
            input=message.encode("utf-8"),
            capture_output=True,
            timeout=5
        )
        if load_result.returncode != 0:
            return False
        try:
            # Paste buffer to pane
            paste_result = subprocess.run(
                ["tmux", "paste-buffer", "-p", "-t", pane_id, "-b", buffer_name],
                capture_output=True,
                timeout=5
            )
            if paste_result.returncode == 0:
                # Send Enter after paste (wait 1s for stability)
                time.sleep(1.0)
                subprocess.run(
                    ["tmux", "send-keys", "-t", pane_id, "Enter"],
                    capture_output=True,
                    timeout=5
                )
                return True
        finally:
            # Clean up buffer
            subprocess.run(
                ["tmux", "delete-buffer", "-b", buffer_name],
                capture_output=True,
                timeout=2
            )
    except Exception:
        pass
    return False


def find_ask_command() -> str | None:
    """Find the ask command in common locations."""
    ask_paths = [
        Path(__file__).resolve().parent / "ask",
        Path.home() / ".local" / "share" / "codex-dual" / "bin" / "ask",
        Path.home() / ".local" / "bin" / "ask",
    ]
    # On Windows, also check LOCALAPPDATA
    if os.name == "nt":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            ask_paths.insert(0, Path(localappdata) / "codex-dual" / "bin" / "ask")

    for p in ask_paths:
        if p.exists():
            return str(p)
    return None


def send_email_reply(provider: str, reply_content: str) -> bool:
    """Send reply via email when CCB_CALLER=email."""
    try:
        from mail import load_config, SmtpSender
        from mail.ask_handler import load_email_context, cleanup_email_context
        from email.header import decode_header
    except ImportError as e:
        print(f"[completion-hook] Failed to import mail module: {e}", file=sys.stderr)
        return False

    # Get email context from environment or saved file
    req_id = os.environ.get("CCB_EMAIL_REQ_ID", "")
    msg_id = os.environ.get("CCB_EMAIL_MSG_ID", "")
    from_addr = os.environ.get("CCB_EMAIL_FROM", "")

    # Try to load from saved context if env vars missing
    original_subject = ""
    references = ""
    if req_id:
        context = load_email_context(req_id)
        if context:
            msg_id = msg_id or context.get("message_id", "")
            from_addr = from_addr or context.get("from_addr", "")
            original_subject = context.get("subject", "")
            references = context.get("references", "")

    if not from_addr:
        print("[completion-hook] No email recipient (CCB_EMAIL_FROM)", file=sys.stderr)
        return False

    # Load mail config and send
    config = load_config()
    if not config.enabled:
        print("[completion-hook] Mail service not enabled", file=sys.stderr)
        return False

    # Decode MIME-encoded subject if needed
    if original_subject:
        try:
            decoded_parts = decode_header(original_subject)
            subject_parts = []
            for part, charset in decoded_parts:
                if isinstance(part, bytes):
                    subject_parts.append(part.decode(charset or 'utf-8', errors='replace'))
                else:
                    subject_parts.append(part)
            original_subject = ''.join(subject_parts)
        except Exception:
            pass

    # Clean subject: remove Re:/回复：/回复: prefixes
    subject = original_subject
    if subject:
        import re
        # Remove common reply prefixes (case insensitive)
        subject = re.sub(r'^(Re:\s*|RE:\s*|回复：\s*|回复:\s*)+', '', subject, flags=re.IGNORECASE)

    if not subject:
        subject = f"[CCB] {provider.capitalize()} response"

    # Build references chain for threading
    refs = ""
    if references and msg_id:
        refs = f"{references} {msg_id}"
    elif references:
        refs = references
    elif msg_id:
        refs = msg_id

    sender = SmtpSender(config)
    body = f"[{provider.capitalize()}] {reply_content}"

    success, result = sender.send_reply(
        to_addr=from_addr,
        subject=subject,
        body=body,
        in_reply_to=msg_id if msg_id else None,
        references=refs if refs else None,
        provider=provider,
    )

    if success:
        print(f"[completion-hook] Email reply sent to {from_addr}")
        # Cleanup saved context
        if req_id:
            cleanup_email_context(req_id)
        return True
    else:
        print(f"[completion-hook] Failed to send email: {result}", file=sys.stderr)
        return False


def main() -> int:
    if not env_bool("CCB_COMPLETION_HOOK_ENABLED", True):
        return 0

    parser = argparse.ArgumentParser(description="CCB Completion Hook")
    parser.add_argument("--provider", required=True, help="Provider name")
    parser.add_argument("--caller", default="claude", help="Who initiated the request")
    parser.add_argument("--output", default="", help="Output file path (optional)")
    parser.add_argument("--reply", default="", help="Reply text (optional)")
    parser.add_argument("--req-id", default="", help="Request ID")
    args = parser.parse_args()

    provider = args.provider.lower()
    output_file = args.output or None

    # Check CCB_CALLER env var first, then fall back to --caller arg
    caller = os.environ.get("CCB_CALLER", "").strip().lower()
    if not caller:
        caller = args.caller.lower()

    # Read reply from stdin using cross-platform helper
    reply_content = ""
    if not sys.stdin.isatty():
        reply_content = read_stdin_text()
    if not reply_content:
        reply_content = args.reply or ""

    # Handle email caller - send reply via email
    if caller == "email":
        if send_email_reply(provider, reply_content):
            return 0
        return 1

    # Terminal caller - construct notification message
    provider_names = {
        "codex": "Codex",
        "gemini": "Gemini",
        "opencode": "OpenCode",
        "droid": "Droid",
    }
    provider_display = provider_names.get(provider, provider.capitalize())
    req_id = args.req_id or "unknown"

    if output_file:
        message = f"""CCB_REQ_ID: {req_id}

[CCB_TASK_COMPLETED]
Provider: {provider_display}
Output file: {output_file}

Result: {reply_content}
"""
    else:
        message = f"""CCB_REQ_ID: {req_id}

[CCB_TASK_COMPLETED]
Provider: {provider_display}

Result: {reply_content}
"""

    # Find caller's pane_id from session file
    session_files = {
        "claude": ".claude-session",
        "codex": ".codex-session",
        "droid": ".droid-session",
    }
    session_filename = session_files.get(caller, ".claude-session")

    # Search for session file in multiple locations (order matters - most specific first)
    work_dir = os.environ.get("CCB_WORK_DIR", "")
    search_paths = []

    # 1. Request's work_dir (most specific)
    if work_dir:
        search_paths.append(Path(work_dir) / ".ccb_config" / session_filename)

    # 2. Current working directory (fallback)
    cwd = os.getcwd()
    if cwd != work_dir:
        search_paths.append(Path(cwd) / ".ccb_config" / session_filename)

    # 3. User's home-based locations
    search_paths.append(Path.home() / ".local" / "share" / "codex-dual" / ".ccb_config" / session_filename)

    # 4. On Windows, also check LOCALAPPDATA
    if os.name == "nt":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            search_paths.insert(0, Path(localappdata) / "codex-dual" / ".ccb_config" / session_filename)

    pane_id = None
    terminal = "tmux"  # default
    session_data = {}
    found_session_path = None

    for session_path in search_paths:
        if session_path.exists():
            session_data = load_session_file(session_path)
            pane_id = session_data.get("pane_id")
            terminal = session_data.get("terminal", "tmux")
            if pane_id:
                found_session_path = session_path
                # Validate: check if session's work_dir matches request's work_dir
                session_work_dir = session_data.get("work_dir", "")
                if work_dir and session_work_dir and session_work_dir != work_dir:
                    # Session file is for a different project, skip it
                    pane_id = None
                    continue
                break

    if not pane_id:
        # No pane_id found, try ask command
        timeout = env_float("CCB_COMPLETION_HOOK_TIMEOUT", 10.0)
        ask_cmd = find_ask_command()
        if not ask_cmd:
            return 0
        try:
            # Use sys.executable to run ask command on Windows
            if os.name == "nt":
                result = subprocess.run(
                    [sys.executable, ask_cmd, caller, "--notify", "--no-wrap", message],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            else:
                result = subprocess.run(
                    [ask_cmd, caller, "--notify", "--no-wrap", message],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            return result.returncode
        except Exception:
            return 0

    # Send directly via terminal backend
    if send_via_terminal(pane_id, message, terminal, session_data):
        return 0

    # Fallback to ask command if terminal send failed
    timeout = env_float("CCB_COMPLETION_HOOK_TIMEOUT", 10.0)
    ask_cmd = find_ask_command()
    if not ask_cmd:
        return 0
    try:
        if os.name == "nt":
            subprocess.run(
                [sys.executable, ask_cmd, caller, "--notify", "--no-wrap", message],
                capture_output=True,
                text=True,
                timeout=timeout
            )
        else:
            subprocess.run(
                [ask_cmd, caller, "--notify", "--no-wrap", message],
                capture_output=True,
                text=True,
                timeout=timeout
            )
    except Exception:
        pass
    return 0


if __name__ == "__main__":
    sys.exit(main())
