#!/usr/bin/env python
"""
oask - Send message to OpenCode and wait for reply (sync).

Designed to be used with Claude Code's run_in_background=true.
If --output is provided, the reply is written atomically to that file and stdout stays empty.
"""
from __future__ import annotations

import os
import sys
import time
from pathlib import Path
from typing import Optional, Tuple

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding

setup_windows_encoding()
from env_utils import env_bool
from process_lock import ProviderLock
from askd_client import (
    autostart_enabled,
    state_file_from_env,
    find_project_session_file,
    try_daemon_request,
    maybe_start_daemon,
    wait_for_daemon_ready,
    check_background_mode,
)
from providers import OASK_CLIENT_SPEC


def _daemon_request_with_retries(work_dir: Path, message: str, timeout: float, quiet: bool) -> Optional[tuple[str, int]]:
    """
    Best-effort daemon request with retries to avoid autostart races.

    Without this, a burst of concurrent `oask` invocations can fall back to direct mode
    before the daemon is fully ready, causing only some requests to be submitted.
    """
    state_file = state_file_from_env(OASK_CLIENT_SPEC.state_file_env)

    # Fast path
    result = try_daemon_request(OASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file)
    if result is not None:
        return result

    # If daemon mode is disabled or no session, don't spin.
    if not env_bool(OASK_CLIENT_SPEC.enabled_env, True):
        return None
    if not find_project_session_file(work_dir, OASK_CLIENT_SPEC.session_filename):
        return None

    # Stale state files can block daemon mode (e.g. daemon exited/crashed but the json remains).
    if state_file and state_file.exists():
        try:
            from oaskd_daemon import ping_daemon

            if not ping_daemon(timeout_s=0.2, state_file=state_file):
                try:
                    state_file.unlink()
                except Exception:
                    pass
        except Exception:
            pass

    started = maybe_start_daemon(OASK_CLIENT_SPEC, work_dir)
    if started:
        wait_for_daemon_ready(OASK_CLIENT_SPEC, _daemon_startup_wait_s(timeout), state_file)

    # Retry briefly; re-reading state helps when multiple daemons were attempted.
    wait_s = _daemon_retry_wait_s(timeout)
    deadline = time.time() + min(3.0, max(0.2, float(timeout)))
    while time.time() < deadline:
        result = try_daemon_request(OASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file)
        if result is not None:
            return result
        time.sleep(wait_s)

    return None


def _daemon_startup_wait_s(timeout: float) -> float:
    raw = (os.environ.get("CCB_OASKD_STARTUP_WAIT_S") or "").strip()
    if raw:
        try:
            v = float(raw)
        except Exception:
            v = 0.0
        if v > 0:
            return min(max(0.2, v), max(0.2, float(timeout)))
    # Default: allow a bit more time for concurrent first-start races.
    return min(8.0, max(1.0, float(timeout)))


def _daemon_retry_wait_s(timeout: float) -> float:
    raw = (os.environ.get("CCB_OASKD_RETRY_WAIT_S") or "").strip()
    if raw:
        try:
            v = float(raw)
        except Exception:
            v = 0.0
        if v > 0:
            return min(1.0, max(0.05, v))
    return min(0.3, max(0.05, float(timeout) / 50.0))


def _wait_for_done_reply(log_reader, state: dict, timeout: float, req_id: str, quiet: bool):
    from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK
    from oaskd_protocol import is_done_text, strip_done_text

    deadline = time.time() + timeout
    chunks: list[str] = []
    cancel_enabled = env_bool("CCB_OASKD_CANCEL_DETECT", False)
    session_id = state.get("session_id") if cancel_enabled and isinstance(state.get("session_id"), str) else None
    cancel_cursor = log_reader.open_cancel_log_cursor() if cancel_enabled and session_id else None
    cancel_since_s = time.time() if cancel_enabled else 0.0

    while True:
        remaining = deadline - time.time()
        if remaining <= 0:
            break
        reply, state = log_reader.wait_for_message(state, min(remaining, 1.0))

        # Fallback cancellation detection via OpenCode server logs.
        if cancel_enabled and session_id and cancel_cursor is not None:
            try:
                cancelled_log, cancel_cursor = log_reader.detect_cancel_event_in_logs(
                    cancel_cursor, session_id=session_id, since_epoch_s=cancel_since_s
                )
                if cancelled_log:
                    return "❌ OpenCode request cancelled.", EXIT_ERROR
            except Exception:
                pass

        # OpenCode cancellation writes an assistant message with MessageAbortedError (no text parts).
        #
        # Important: do NOT advance the caller's state baseline when not cancelled (see oaskd_daemon).
        if cancel_enabled:
            try:
                cancelled, _new_state = log_reader.detect_cancelled_since(state, req_id=req_id)
                if cancelled:
                    return "❌ OpenCode request cancelled.", EXIT_ERROR
            except Exception:
                pass

        if reply is None:
            continue
        chunks.append(reply)
        combined = "\n".join(chunks)
        if is_done_text(combined, req_id):
            return strip_done_text(combined, req_id), EXIT_OK

    combined = "\n".join(chunks)
    if combined and not quiet:
        print("[WARN] Done marker not detected, returning partial reply", file=sys.stderr)
    return strip_done_text(combined, req_id), EXIT_NO_REPLY


def _usage() -> None:
    print("Usage: oask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)


def _parse_args(argv: list[str]) -> Tuple[Optional[Path], float, str, bool]:
    output: Optional[Path] = None
    timeout: Optional[float] = None
    quiet = False
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            raise SystemExit(0)
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token in ("-o", "--output"):
            try:
                output = Path(next(it)).expanduser()
            except StopIteration:
                raise ValueError("--output requires a file path")
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                raise ValueError("--timeout requires a number")
            except ValueError as exc:
                raise ValueError(f"Invalid --timeout: {exc}")
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        except Exception:
            timeout = 3600.0
    return output, timeout, message, quiet


def main(argv: list[str]) -> int:
    try:
        from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK, atomic_write_text
        from opencode_comm import OpenCodeCommunicator
        from opencode_comm import OpenCodeLogReader
        from oaskd_protocol import make_req_id, wrap_opencode_prompt

        output_path, timeout, message, quiet = _parse_args(argv)
        if not message and not sys.stdin.isatty():
            message = sys.stdin.read().strip()
        if not message:
            _usage()
            return EXIT_ERROR

        if os.environ.get("CLAUDECODE") == "1" and not check_background_mode():
            print("[ERROR] oask MUST be called with run_in_background=true", file=sys.stderr)
            print("Correct usage: Bash(oask \"...\", run_in_background=true)", file=sys.stderr)
            return EXIT_ERROR

        # Prefer daemon mode: daemon performs per-session serialization and should accept concurrent submissions.
        daemon_result = _daemon_request_with_retries(Path.cwd(), message, timeout, quiet)
        if daemon_result is not None:
            reply, exit_code = daemon_result
            if output_path:
                atomic_write_text(output_path, reply + "\n")
                return exit_code
            sys.stdout.write(reply)
            if not reply.endswith("\n"):
                sys.stdout.write("\n")
            return exit_code

        comm = OpenCodeCommunicator(lazy_init=True)
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            raise RuntimeError(f"[ERROR] Session error: {status}")

        # Prefer the canonical session_key computation used by the daemon to avoid cross-mode
        # serialization mismatches (e.g. if one caller sees marker while another doesn't).
        try:
            from oaskd_session import compute_session_key, load_project_session

            session = load_project_session(Path.cwd())
        except Exception:
            session = None

        if session:
            session_key = compute_session_key(session)
        else:
            marker = str(comm.session_info.get("pane_title_marker") or "").strip()
            if marker:
                session_key = f"opencode_marker:{marker}"
            elif comm.pane_id:
                session_key = f"opencode_pane:{comm.pane_id}"
            else:
                sid = str(comm.session_info.get("session_id") or comm.session_id or "").strip()
                if sid:
                    session_key = f"opencode:{sid}"
                else:
                    session_key = f"opencode_file:{comm.project_session_file or os.getcwd()}"

        lock = ProviderLock("opencode", cwd=f"session:{session_key}", timeout=min(300.0, max(1.0, float(timeout))))
        if not lock.acquire():
            print("[ERROR] Another oask request is in progress (lock timeout).", file=sys.stderr)
            return EXIT_ERROR

        try:
            # Clear output file if specified (avoid stale content)
            if output_path and output_path.exists():
                output_path.write_text("")

            req_id = make_req_id()
            log_reader = OpenCodeLogReader(work_dir=Path.cwd(), session_id_filter=(comm.session_id or None))
            state = log_reader.capture_state()
            comm._send_via_terminal(wrap_opencode_prompt(message, req_id))

            reply, exit_code = _wait_for_done_reply(log_reader, state, timeout, req_id, quiet)
            if reply is None:
                if not quiet:
                    print(f"[TIMEOUT] Timeout after {int(timeout)}s", file=sys.stderr)
                return exit_code

            if output_path:
                atomic_write_text(output_path, reply + "\n")
                return exit_code
        finally:
            lock.release()

        sys.stdout.write(reply)
        if not reply.endswith("\n"):
            sys.stdout.write("\n")
        return exit_code
    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
