#!/usr/bin/env python3
"""
ccb (Claude Code Bridge) - ç»Ÿä¸€ AI å¯åŠ¨å™¨
æ”¯æŒ Claude + Codex / Claude + Gemini / ä¸‰è€…åŒæ—¶
æ”¯æŒ tmuxã€WezTerm å’Œ iTerm2 ç»ˆç«¯
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
import tempfile
import re
import shutil
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import TmuxBackend, WeztermBackend, Iterm2Backend, detect_terminal, is_wsl, get_shell_type
from compat import setup_windows_encoding

setup_windows_encoding()

VERSION = "2.1"


def _get_git_info() -> str:
    try:
        result = subprocess.run(
            ["git", "-C", str(script_dir), "log", "-1", "--format=%h %ci"],
            capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=2
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    return ""


def _build_keep_open_cmd(provider: str, start_cmd: str) -> str:
    if get_shell_type() == "powershell":
        return (
            f'{start_cmd}; '
            f'$code = $LASTEXITCODE; '
            f'Write-Host "`n[{provider}] exited with code $code. Press Enter to close..."; '
            f'Read-Host; '
            f'exit $code'
        )
    return (
        f'{start_cmd}; '
        f'code=$?; '
        f'echo; echo "[{provider}] exited with code $code. Press Enter to close..."; '
        f'read -r _; '
        f'exit $code'
    )


class AILauncher:
    def __init__(self, providers: list, resume: bool = False, auto: bool = False, no_claude: bool = False):
        self.providers = providers or ["codex"]
        self.resume = resume
        self.auto = auto
        self.no_claude = no_claude
        self.script_dir = Path(__file__).resolve().parent
        self.session_id = f"ai-{int(time.time())}-{os.getpid()}"
        self.temp_base = Path(tempfile.gettempdir())
        self.runtime_dir = self.temp_base / f"claude-ai-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)
        self._cleaned = False
        self.terminal_type = self._detect_terminal_type()
        self.tmux_sessions = {}
        self.wezterm_panes = {}
        self.iterm2_panes = {}
        self.processes = {}

    def _detect_terminal_type(self):
        # ç¯å¢ƒå˜é‡å¼ºåˆ¶æŒ‡å®š
        forced = (os.environ.get("CCB_TERMINAL") or os.environ.get("CODEX_TERMINAL") or "").strip().lower()
        if forced in {"wezterm", "tmux"}:
            return forced

        # åœ¨ WezTerm pane å†…æ—¶ï¼Œå¼ºåˆ¶ä½¿ç”¨ weztermï¼Œå®Œå…¨ä¸ä¾èµ– tmux
        if os.environ.get("WEZTERM_PANE"):
            return "wezterm"
        # åªæœ‰åœ¨ iTerm2 ç¯å¢ƒä¸­æ‰ç”¨ iTerm2 åˆ†å±
        if os.environ.get("ITERM_SESSION_ID"):
            return "iterm2"

        # ä½¿ç”¨ detect_terminal() è‡ªåŠ¨æ£€æµ‹ï¼ˆWezTerm ä¼˜å…ˆï¼‰
        detected = detect_terminal()
        if detected:
            return detected

        # å…œåº•ï¼šå¦‚æœéƒ½æ²¡æœ‰ï¼Œè¿”å› None è®©åç»­é€»è¾‘å¤„ç†
        return None

    def _detect_launch_terminal(self):
        """é€‰æ‹©ç”¨äºå¯åŠ¨æ–°çª—å£çš„ç»ˆç«¯ç¨‹åºï¼ˆä»… tmux æ¨¡å¼ä¸‹ä½¿ç”¨ï¼‰"""
        # WezTerm æ¨¡å¼ä¸éœ€è¦å¤–éƒ¨ç»ˆç«¯ç¨‹åº
        if self.terminal_type == "wezterm":
            return None
        # tmux æ¨¡å¼ä¸‹é€‰æ‹©ç»ˆç«¯
        terminals = ["gnome-terminal", "konsole", "alacritty", "xterm"]
        for term in terminals:
            if shutil.which(term):
                return term
        return "tmux"

    def _launch_script_in_macos_terminal(self, script_file: Path) -> bool:
        """macOS: ä½¿ç”¨ Terminal.app æ‰“å¼€æ–°çª—å£æ‰§è¡Œè„šæœ¬ï¼ˆé¿å… tmux launcher åµŒå¥—å¯¼è‡´äº¤äº’å¤±è´¥ï¼‰"""
        if platform.system() != "Darwin":
            return False
        if not shutil.which("osascript"):
            return False
        env = os.environ.copy()
        env["CCB_WRAPPER_SCRIPT"] = str(script_file)
        subprocess.Popen(
            [
                "osascript",
                "-e",
                'tell application "Terminal" to do script "/bin/bash " & quoted form of (system attribute "CCB_WRAPPER_SCRIPT")',
                "-e",
                'tell application "Terminal" to activate',
            ],
            env=env,
        )
        return True

    def _start_provider(self, provider: str) -> bool:
        # å¤„ç†æœªæ£€æµ‹åˆ°ç»ˆç«¯çš„æƒ…å†µ
        if self.terminal_type is None:
            print("âŒ æœªæ£€æµ‹åˆ°å¯ç”¨çš„ç»ˆç«¯åç«¯ï¼ˆWezTerm æˆ– tmuxï¼‰")
            print("   è§£å†³æ–¹æ¡ˆ:")
            print("   - å®‰è£… WezTermï¼ˆæ¨èï¼‰: https://wezfurlong.org/wezterm/")
            print("   - æˆ–å®‰è£… tmux")
            print("   - æˆ–è®¾ç½®ç¯å¢ƒå˜é‡ CCB_TERMINAL=wezterm å¹¶é…ç½® CODEX_WEZTERM_BIN")
            return False

        # WezTerm æ¨¡å¼ï¼šå®Œå…¨ä¸ä¾èµ– tmux
        if self.terminal_type == "wezterm":
            print(f"ğŸš€ å¯åŠ¨ {provider.capitalize()} åç«¯ (wezterm)...")
            return self._start_provider_wezterm(provider)
        elif self.terminal_type == "iterm2":
            return self._start_provider_iterm2(provider)

        # tmux æ¨¡å¼ï¼šæ£€æŸ¥ tmux æ˜¯å¦å¯ç”¨
        if not shutil.which("tmux"):
            # å°è¯• fallback åˆ° WezTerm
            if detect_terminal() == "wezterm":
                self.terminal_type = "wezterm"
                print(f"ğŸš€ å¯åŠ¨ {provider.capitalize()} åç«¯ (wezterm - tmux ä¸å¯ç”¨)...")
                return self._start_provider_wezterm(provider)
            else:
                print("âŒ tmux æœªå®‰è£…ï¼Œä¸” WezTerm ä¸å¯ç”¨")
                print("   è§£å†³æ–¹æ¡ˆ: å®‰è£… WezTermï¼ˆæ¨èï¼‰æˆ– tmux")
                return False

        print(f"ğŸš€ å¯åŠ¨ {provider.capitalize()} åç«¯ (tmux)...")

        tmux_session = f"{provider}-{int(time.time()) % 100000}-{os.getpid()}"
        self.tmux_sessions[provider] = tmux_session

        if provider == "codex":
            return self._start_codex(tmux_session)
        elif provider == "gemini":
            return self._start_gemini(tmux_session)
        else:
            print(f"âŒ æœªçŸ¥çš„ provider: {provider}")
            return False

    def _start_provider_wezterm(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        keep_open = os.environ.get("CODEX_WEZTERM_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = _build_keep_open_cmd(provider, start_cmd)
        # Layout: first backend splits to the right of current pane, subsequent backends stack below
        # the first backend pane to form a right-side column (top/bottom).
        direction = "right" if not self.wezterm_panes else "bottom"
        parent_pane = None
        if direction == "bottom":
            try:
                parent_pane = next(iter(self.wezterm_panes.values()))
            except StopIteration:
                parent_pane = None

        backend = WeztermBackend()
        pane_id = backend.create_pane(start_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.wezterm_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # WezTerm æ¨¡å¼é€šè¿‡ pane æ³¨å…¥æ–‡æœ¬ï¼Œä¸å¼ºä¾èµ– FIFOï¼›Windows/WSL åœºæ™¯ä¹Ÿä¸ä¸€å®šæ”¯æŒ mkfifoã€‚
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id)
        else:
            self._write_gemini_session(runtime, None, pane_id=pane_id)

        print(f"âœ… {provider.capitalize()} å·²å¯åŠ¨ (wezterm pane: {pane_id})")
        return True

    def _start_provider_iterm2(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        # iTerm2 åˆ†å±é‡Œï¼Œè¿›ç¨‹é€€å‡ºä¼šå¯¼è‡´ pane ç›´æ¥å…³é—­ï¼›é»˜è®¤ä¿æŒ pane æ‰“å¼€ä¾¿äºæŸ¥çœ‹é€€å‡ºä¿¡æ¯ã€‚
        keep_open = os.environ.get("CODEX_ITERM2_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = (
                f"{start_cmd}; "
                f"code=$?; "
                f'echo; echo \"[{provider}] exited with code $code. Press Enter to close...\"; '
                f"read -r _; "
                f"exit $code"
            )
        # Layout: first backend splits to the right of current pane, subsequent backends stack below
        direction = "right" if not self.iterm2_panes else "bottom"
        parent_pane = None
        if direction == "bottom":
            try:
                parent_pane = next(iter(self.iterm2_panes.values()))
            except StopIteration:
                parent_pane = None

        backend = Iterm2Backend()
        pane_id = backend.create_pane(start_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.iterm2_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # iTerm2 æ¨¡å¼é€šè¿‡ pane æ³¨å…¥æ–‡æœ¬ï¼Œä¸å¼ºä¾èµ– FIFO
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id)
        else:
            self._write_gemini_session(runtime, None, pane_id=pane_id)

        print(f"âœ… {provider.capitalize()} å·²å¯åŠ¨ (iterm2 session: {pane_id})")
        return True

    def _work_dir_strings(self, work_dir: Path) -> list[str]:
        candidates: list[str] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            candidates.append(env_pwd)
        candidates.append(str(work_dir))
        try:
            candidates.append(str(work_dir.resolve()))
        except Exception:
            pass
        # de-dup while preserving order
        seen: set[str] = set()
        result: list[str] = []
        for candidate in candidates:
            if candidate not in seen:
                seen.add(candidate)
                result.append(candidate)
        return result

    def _read_json_file(self, path: Path) -> dict:
        try:
            if not path.exists():
                return {}
            data = json.loads(path.read_text())
            return data if isinstance(data, dict) else {}
        except Exception:
            return {}

    def _write_json_file(self, path: Path, data: dict) -> None:
        try:
            path.write_text(json.dumps(data, ensure_ascii=False, indent=2))
        except Exception:
            pass

    def _claude_session_file(self) -> Path:
        return Path.cwd() / ".claude-session"

    def _read_local_claude_session_id(self) -> str | None:
        data = self._read_json_file(self._claude_session_file())
        sid = data.get("claude_session_id") or data.get("session_id")
        if isinstance(sid, str) and sid.strip():
            return sid.strip()
        return None

    def _write_local_claude_session(self, session_id: str, active: bool = True) -> None:
        path = self._claude_session_file()
        data = self._read_json_file(path)
        data.update(
            {
                "claude_session_id": session_id,
                "work_dir": str(Path.cwd()),
                "active": bool(active),
                "started_at": data.get("started_at") or time.strftime("%Y-%m-%d %H:%M:%S"),
                "updated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            }
        )
        self._write_json_file(path, data)

    def _get_latest_codex_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history_for_cwd).
        Session id is Codex CLI's UUID used by `codex resume <id>`.
        """
        # Only trust local project state; deleting local dotfiles should reset resume behavior.
        project_session = Path.cwd() / ".codex-session"
        if project_session.exists():
            try:
                data = json.loads(project_session.read_text())
                cached = data.get("codex_session_id")
                if isinstance(cached, str) and cached:
                    return cached, True
            except Exception:
                pass
        return None, False

    def _build_codex_start_cmd(self) -> str:
        cmd = "codex -c disable_paste_burst=true --full-auto" if self.auto else "codex -c disable_paste_burst=true"
        codex_resumed = False
        if self.resume:
            session_id, has_history = self._get_latest_codex_session_id()
            if session_id:
                cmd = f"{cmd} resume {session_id}"
                print(f"ğŸ” Resuming Codex session: {session_id[:8]}...")
                codex_resumed = True

            if not codex_resumed:
                print("â„¹ï¸ No Codex history found, starting fresh")
        return cmd

    def _get_latest_gemini_project_hash(self) -> tuple[str | None, bool]:
        """
        Returns (project_hash, has_any_history_for_cwd).
        Gemini CLI stores sessions under ~/.gemini/tmp/<sha256(cwd)>/chats/.
        """
        # Only trust local project state; deleting local dotfiles should reset resume behavior.
        project_session = Path.cwd() / ".gemini-session"
        if not project_session.exists():
            return None, False
        try:
            data = json.loads(project_session.read_text())
        except Exception:
            data = {}
        if not isinstance(data, dict):
            return None, True
        project_hash = data.get("gemini_project_hash")
        if isinstance(project_hash, str) and project_hash.strip():
            return project_hash.strip(), True
        return None, True

    def _build_gemini_start_cmd(self) -> str:
        cmd = "gemini --yolo" if self.auto else "gemini"
        if self.resume:
            _, has_history = self._get_latest_gemini_project_hash()
            if has_history:
                cmd = f"{cmd} --resume latest"
                print("ğŸ” Resuming Gemini session...")
            else:
                print("â„¹ï¸ No Gemini history found, starting fresh")
        return cmd

    def _warmup_provider(self, provider: str, timeout: float = 8.0) -> bool:
        if provider == "codex":
            ping_script = self.script_dir / "bin" / "cping"
        elif provider == "gemini":
            ping_script = self.script_dir / "bin" / "gping"
        else:
            return False

        if not ping_script.exists():
            return False

        print(f"ğŸ”§ Warmup: {ping_script.name}")
        deadline = time.time() + timeout
        last_result: subprocess.CompletedProcess[str] | None = None
        sleep_s = 0.3
        while time.time() < deadline:
            last_result = subprocess.run(
                [sys.executable, str(ping_script)],
                cwd=str(Path.cwd()),
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
            )
            if last_result.returncode == 0:
                out = (last_result.stdout or "").strip()
                if out:
                    print(out)
                return True
            time.sleep(sleep_s)
            sleep_s = min(1.0, sleep_s * 1.5)

        if last_result:
            out = ((last_result.stdout or "") + "\n" + (last_result.stderr or "")).strip()
            if out:
                print(out)
        print(f"âš ï¸ Warmup failed: {provider}")
        return False

    def _get_start_cmd(self, provider: str) -> str:
        if provider == "codex":
            # NOTE: Codex TUI æœ‰ paste-burst æ£€æµ‹ï¼›ç»ˆç«¯æ³¨å…¥ï¼ˆwezterm send-text/tmux paste-bufferï¼‰
            # å¾€å¾€ä¼šè¢«è¯†åˆ«ä¸ºâ€œç²˜è´´â€ï¼Œå¯¼è‡´å›è½¦ä»…æ¢è¡Œä¸æäº¤ã€‚é»˜è®¤å…³é—­è¯¥æ£€æµ‹ï¼Œä¿è¯è‡ªåŠ¨é€šä¿¡å¯ç”¨ã€‚
            return self._build_codex_start_cmd()
        elif provider == "gemini":
            return self._build_gemini_start_cmd()
        return ""

    def _start_codex(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "codex"
        runtime.mkdir(parents=True, exist_ok=True)

        input_fifo = runtime / "input.fifo"
        output_fifo = runtime / "output.fifo"

        if not input_fifo.exists():
            os.mkfifo(input_fifo, 0o600)
        if not output_fifo.exists():
            os.mkfifo(output_fifo, 0o644)

        start_cmd = self._build_codex_start_cmd()

        bridge_script = self.script_dir / "lib" / "codex_dual_bridge.py"
        wrapper = f'''#!/bin/bash
SESSION_ID="{self.session_id}"
RUNTIME_DIR="{runtime}"
TMUX_SESSION="{tmux_session}"
BRIDGE_SCRIPT="{bridge_script}"
PYTHON_BIN="{sys.executable}"
SCRIPT_DIR="{self.script_dir}"
WORK_DIR="{os.getcwd()}"
INPUT_FIFO="{input_fifo}"
OUTPUT_FIFO="{output_fifo}"
TMUX_LOG_FILE="{runtime}/bridge_output.log"

echo $$ > "$RUNTIME_DIR/codex.pid"
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_INPUT_FIFO="$INPUT_FIFO"
export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
export CODEX_TMUX_SESSION="$TMUX_SESSION"
export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

CODEX_START_CMD={json.dumps(start_cmd)}

if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    cd "$WORK_DIR"
    tmux new-session -d -s "$TMUX_SESSION" "$CODEX_START_CMD"
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$RUNTIME_DIR/bridge.log" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$RUNTIME_DIR/bridge.pid"

trap 'kill -TERM "$BRIDGE_PID" 2>/dev/null' EXIT
exec tmux attach -t "$TMUX_SESSION"
'''
        script_file = runtime / "wrapper.sh"
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        self._write_codex_session(runtime, tmux_session, input_fifo, output_fifo)

        terminal = self._detect_launch_terminal()
        if terminal == "tmux":
            if self._launch_script_in_macos_terminal(script_file):
                pass
            else:
                subprocess.run(["tmux", "new-session", "-d", "-s", f"launcher-{tmux_session}", str(script_file)], check=True)
        else:
            subprocess.Popen([terminal, "-e", str(script_file)])

        print(f"âœ… Codex å·²å¯åŠ¨ (tmux: {tmux_session})")
        return True

    def _start_gemini(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "gemini"
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._build_gemini_start_cmd()

        script_file = runtime / "wrapper.sh"

        self._write_gemini_session(runtime, tmux_session)

        # åˆ›å»ºå¯åŠ¨è„šæœ¬
        wrapper = f'''#!/bin/bash
	cd "{os.getcwd()}"
	tmux new-session -d -s "{tmux_session}" 2>/dev/null || true
	tmux send-keys -t "{tmux_session}" "{start_cmd}" Enter
	exec tmux attach -t "{tmux_session}"
	'''
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        terminal = self._detect_launch_terminal()
        if terminal == "tmux":
            if self._launch_script_in_macos_terminal(script_file):
                pass
            else:
                # çº¯ tmux æ¨¡å¼
                subprocess.run(["tmux", "new-session", "-d", "-s", tmux_session], check=True, cwd=os.getcwd())
                backend = TmuxBackend()
                deadline = time.time() + 1.0
                sleep_s = 0.05
                while True:
                    try:
                        backend.send_text(tmux_session, start_cmd)
                        break
                    except subprocess.CalledProcessError:
                        if time.time() >= deadline:
                            raise
                        time.sleep(sleep_s)
                        sleep_s = min(0.2, sleep_s * 2)
        else:
            # æ‰“å¼€æ–°ç»ˆç«¯çª—å£
            subprocess.Popen([terminal, "--", str(script_file)])

        print(f"âœ… Gemini å·²å¯åŠ¨ (tmux: {tmux_session})")
        return True

    def _write_codex_session(self, runtime, tmux_session, input_fifo, output_fifo, pane_id=None):
        session_file = Path.cwd() / ".codex-session"
        data = {}
        if session_file.exists():
            try:
                data = json.loads(session_file.read_text())
            except Exception:
                pass

        data.update({
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "input_fifo": str(input_fifo),
            "output_fifo": str(output_fifo),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "tmux_log": str(runtime / "bridge_output.log"),
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        })
        session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _write_gemini_session(self, runtime, tmux_session, pane_id=None):
        session_file = Path.cwd() / ".gemini-session"
        data = {
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        }
        session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _claude_project_dir(self, work_dir: Path) -> Path:
        projects_root = Path.home() / ".claude" / "projects"
        # Claude Code uses a filesystem-friendly key derived from the working directory.
        # To handle symlinked paths (PWD) vs physical paths (resolve()), try multiple candidates.
        candidates: list[Path] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            try:
                candidates.append(Path(env_pwd))
            except Exception:
                pass
        candidates.extend([work_dir])
        try:
            candidates.append(work_dir.resolve())
        except Exception:
            pass

        for candidate in candidates:
            key = re.sub(r"[^A-Za-z0-9]", "-", str(candidate))
            project_dir = projects_root / key
            if project_dir.exists():
                return project_dir

        # Fallback to a best-effort key even if the directory doesn't exist yet.
        try:
            fallback_path = work_dir.resolve()
        except Exception:
            fallback_path = work_dir
        key = re.sub(r"[^A-Za-z0-9]", "-", str(fallback_path))
        return projects_root / key

    def _get_latest_claude_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history).
        - session_id: latest UUID-like session id if found (for `claude --resume <id>`).
        - has_any_history: whether this project has any Claude sessions on disk.
        """
        project_dir = self._claude_project_dir(Path.cwd())
        if not project_dir.exists():
            return None, False

        session_files = list(project_dir.glob("*.jsonl"))
        if not session_files:
            return None, False

        session_env_root = Path.home() / ".claude" / "session-env"

        uuid_sessions: list[Path] = []
        for session_file in session_files:
            try:
                uuid.UUID(session_file.stem)
                # Ignore zero-byte placeholders and sessions Claude cannot actually resume.
                if session_file.stat().st_size <= 0:
                    continue
                if not (session_env_root / session_file.stem).exists():
                    continue
                uuid_sessions.append(session_file)
            except Exception:
                continue

        if not uuid_sessions:
            return None, True

        latest = max(uuid_sessions, key=lambda p: p.stat().st_mtime)
        return latest.stem, True

    def _find_claude_cmd(self) -> str:
        """Find Claude CLI executable"""
        if sys.platform == "win32":
            for cmd in ["claude.exe", "claude.cmd", "claude.bat", "claude"]:
                path = shutil.which(cmd)
                if path:
                    return path
            npm_paths = [
                Path(os.environ.get("APPDATA", "")) / "npm" / "claude.cmd",
                Path(os.environ.get("ProgramFiles", "")) / "nodejs" / "claude.cmd",
            ]
            for npm_path in npm_paths:
                if npm_path.exists():
                    return str(npm_path)
        else:
            path = shutil.which("claude")
            if path:
                return path
        raise FileNotFoundError(
            "âŒ Claude CLI not found. Install: npm install -g @anthropic-ai/claude-code"
        )

    def _start_claude(self) -> int:
        print("ğŸš€ å¯åŠ¨ Claude...")

        env = os.environ.copy()
        if "codex" in self.providers:
            runtime = self.runtime_dir / "codex"
            env["CODEX_SESSION_ID"] = self.session_id
            env["CODEX_RUNTIME_DIR"] = str(runtime)
            env["CODEX_INPUT_FIFO"] = str(runtime / "input.fifo")
            env["CODEX_OUTPUT_FIFO"] = str(runtime / "output.fifo")
            env["CODEX_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["CODEX_WEZTERM_PANE"] = self.wezterm_panes.get("codex", "")
            elif self.terminal_type == "iterm2":
                env["CODEX_ITERM2_PANE"] = self.iterm2_panes.get("codex", "")
            else:
                env["CODEX_TMUX_SESSION"] = self.tmux_sessions.get("codex", "")

        if "gemini" in self.providers:
            runtime = self.runtime_dir / "gemini"
            env["GEMINI_SESSION_ID"] = self.session_id
            env["GEMINI_RUNTIME_DIR"] = str(runtime)
            env["GEMINI_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["GEMINI_WEZTERM_PANE"] = self.wezterm_panes.get("gemini", "")
            elif self.terminal_type == "iterm2":
                env["GEMINI_ITERM2_PANE"] = self.iterm2_panes.get("gemini", "")
            else:
                env["GEMINI_TMUX_SESSION"] = self.tmux_sessions.get("gemini", "")

        try:
            claude_cmd = self._find_claude_cmd()
        except FileNotFoundError as e:
            print(str(e))
            return 1

        cmd = [claude_cmd]
        if self.auto:
            cmd.append("--dangerously-skip-permissions")
        local_session_id: str | None = None
        if self.resume:
            local_session_id = self._read_local_claude_session_id()
            # Only resume if Claude can actually find the session on disk.
            if local_session_id and (Path.home() / ".claude" / "session-env" / local_session_id).exists():
                cmd.extend(["--resume", local_session_id])
                print(f"ğŸ” Resuming Claude session: {local_session_id[:8]}...")
            else:
                local_session_id = None
                print("â„¹ï¸ No local Claude session found, starting fresh")

        # Always start Claude with an explicit session id when not resuming, so the id is local and resettable.
        if not local_session_id:
            new_id = str(uuid.uuid4())
            cmd.extend(["--session-id", new_id])
            self._write_local_claude_session(new_id, active=True)

        print(f"ğŸ“‹ ä¼šè¯ID: {self.session_id}")
        print(f"ğŸ“ è¿è¡Œç›®å½•: {self.runtime_dir}")
        print(f"ğŸ”Œ æ´»è·ƒåç«¯: {', '.join(self.providers)}")
        print()
        print("ğŸ¯ å¯ç”¨å‘½ä»¤:")
        if "codex" in self.providers:
            print("   cask/cask-w/cping/cpend - Codex é€šä¿¡")
        if "gemini" in self.providers:
            print("   gask/gask-w/gping/gpend - Gemini é€šä¿¡")
        print()
        print(f"æ‰§è¡Œ: {' '.join(cmd)}")

        try:
            return subprocess.run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, env=env).returncode
        except KeyboardInterrupt:
            print("\nâš ï¸ ç”¨æˆ·ä¸­æ–­")
            return 130

    def cleanup(self):
        if self._cleaned:
            return
        self._cleaned = True
        print("\nğŸ§¹ æ¸…ç†ä¼šè¯èµ„æº...")

        if self.terminal_type == "wezterm":
            backend = WeztermBackend()
            for provider, pane_id in self.wezterm_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        elif self.terminal_type == "iterm2":
            backend = Iterm2Backend()
            for provider, pane_id in self.iterm2_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        else:
            for provider, tmux_session in self.tmux_sessions.items():
                subprocess.run(["tmux", "kill-session", "-t", tmux_session], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{tmux_session}"], stderr=subprocess.DEVNULL)

        for session_file in [Path.cwd() / ".codex-session", Path.cwd() / ".gemini-session", Path.cwd() / ".claude-session"]:
            if session_file.exists():
                try:
                    data = json.loads(session_file.read_text())
                    data["active"] = False
                    data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                    session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))
                except Exception:
                    pass

        import shutil
        if self.runtime_dir.exists():
            shutil.rmtree(self.runtime_dir, ignore_errors=True)

        print("âœ… æ¸…ç†å®Œæˆ")

    def run_up(self) -> int:
        git_info = _get_git_info()
        version_str = f"v{VERSION}" + (f" ({git_info})" if git_info else "")
        print(f"ğŸš€ Claude Code Bridge {version_str}")
        print(f"ğŸ“… {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ”Œ åç«¯: {', '.join(self.providers)}")
        print("=" * 50)

        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        providers = list(self.providers)
        if self.terminal_type in ("wezterm", "iterm2"):
            # Stable layout: codex on top, gemini on bottom (when both are present).
            order = {"codex": 0, "gemini": 1}
            providers.sort(key=lambda p: order.get(p, 99))

        for provider in providers:
            if not self._start_provider(provider):
                return 1
            self._warmup_provider(provider)

        if self.no_claude:
            print("âœ… åç«¯å·²å¯åŠ¨ï¼ˆ--no-claude æ¨¡å¼ï¼‰")
            print()
            for provider in self.providers:
                if self.terminal_type == "wezterm":
                    pane = self.wezterm_panes.get(provider, "")
                    if pane:
                        print(f"   {provider}: wezterm cli activate-pane --pane-id {pane}")
                elif self.terminal_type == "iterm2":
                    pane = self.iterm2_panes.get(provider, "")
                    if pane:
                        print(f"   {provider}: it2 session focus {pane}")
                else:
                    tmux = self.tmux_sessions.get(provider, "")
                    if tmux:
                        print(f"   {provider}: tmux attach -t {tmux}")
            print()
            print(f"ç»ˆæ­¢: ccb kill {' '.join(self.providers)}")
            atexit.unregister(self.cleanup)
            return 0

        try:
            return self._start_claude()
        finally:
            self.cleanup()


def cmd_up(args):
    launcher = AILauncher(
        providers=args.providers or ["codex"],
        resume=args.resume,
        auto=args.auto,
        no_claude=args.no_claude,
    )
    return launcher.run_up()


def cmd_status(args):
    providers = args.providers or ["codex", "gemini"]
    results = {}

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            results[provider] = {"status": "æœªé…ç½®", "active": False}
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                alive = backend.is_alive(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                alive = backend.is_alive(pane_id)
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                alive = result.returncode == 0
            else:
                alive = False

            results[provider] = {
                "status": "è¿è¡Œä¸­" if (active and alive) else "å·²åœæ­¢",
                "active": active and alive,
                "terminal": terminal,
                "pane_id": pane_id,
                "runtime_dir": data.get("runtime_dir", ""),
            }
        except Exception as e:
            results[provider] = {"status": f"é”™è¯¯: {e}", "active": False}

    print("ğŸ“Š AI åç«¯çŠ¶æ€:")
    for provider, info in results.items():
        icon = "âœ…" if info.get("active") else "âŒ"
        print(f"  {icon} {provider.capitalize()}: {info['status']}")
        if info.get("pane_id"):
            print(f"     {info.get('terminal', 'tmux')}: {info['pane_id']}")

    return 0


def cmd_kill(args):
    providers = args.providers or ["codex", "gemini"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: æœªæ‰¾åˆ°ä¼šè¯æ–‡ä»¶")
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                backend.kill_pane(pane_id)
            elif pane_id and shutil.which("tmux"):
                subprocess.run(["tmux", "kill-session", "-t", pane_id], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{pane_id}"], stderr=subprocess.DEVNULL)

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

            print(f"âœ… {provider.capitalize()} å·²ç»ˆæ­¢")
        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def cmd_restore(args):
    providers = args.providers or ["codex"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: æœªæ‰¾åˆ°ä¼šè¯æ–‡ä»¶")
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                if result.returncode == 0:
                    subprocess.run(["tmux", "attach-session", "-t", pane_id])
                    return 0

            if not active:
                has_history = False
                session_id = None
                if provider == "codex":
                    session_id = data.get("codex_session_id")
                    if isinstance(session_id, str) and session_id:
                        has_history = True
                    else:
                        # Fallback: scan ~/.codex/sessions for latest session bound to this cwd.
                        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
                        work_dirs = set([os.environ.get("PWD", ""), str(Path.cwd())])
                        try:
                            work_dirs.add(str(Path.cwd().resolve()))
                        except Exception:
                            pass
                        try:
                            logs = sorted(
                                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                                key=lambda p: p.stat().st_mtime,
                                reverse=True,
                            )
                        except Exception:
                            logs = []
                        for log_path in logs[:400]:
                            try:
                                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                                    first = handle.readline().strip()
                            except OSError:
                                continue
                            if not first:
                                continue
                            try:
                                entry = json.loads(first)
                            except Exception:
                                continue
                            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                                continue
                            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
                            cwd = payload.get("cwd")
                            if isinstance(cwd, str) and cwd in work_dirs:
                                has_history = True
                                sid = payload.get("id")
                                if isinstance(sid, str) and sid:
                                    session_id = sid
                                    break
                elif provider == "gemini":
                    gemini_root = Path.home() / ".gemini" / "tmp"
                    if gemini_root.exists():
                        import hashlib
                        candidates = [os.environ.get("PWD", ""), str(Path.cwd())]
                        try:
                            candidates.append(str(Path.cwd().resolve()))
                        except Exception:
                            pass
                        for candidate in candidates:
                            if not candidate:
                                continue
                            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
                            chats_dir = gemini_root / project_hash / "chats"
                            if chats_dir.exists() and any(chats_dir.glob("session-*.json")):
                                has_history = True
                                break

                if has_history:
                    print(f"â„¹ï¸ {provider}: ä¼šè¯å·²ç»“æŸï¼Œä½†å¯æ¢å¤å†å²ä¼šè¯")
                    if session_id:
                        print(f"   ä¼šè¯ID: {session_id[:8]}...")
                    print(f"   ä½¿ç”¨: ccb up {provider} -r")
                else:
                    print(f"âš ï¸ {provider}: ä¼šè¯å·²ç»“æŸï¼Œæ— å¯æ¢å¤å†å²")
            else:
                print(f"âš ï¸ {provider}: ä¼šè¯å·²ä¸¢å¤±ï¼Œä½¿ç”¨ ccb up {provider} -r é‡å¯")

        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def cmd_update(args):
    """Update ccb to latest version"""
    import shutil
    import urllib.request
    import tarfile
    import tempfile

    # Prefer the directory where this script resides (installed copy), then fall back to env/default.
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root
    repo_url = "https://github.com/bfly123/claude_code_bridge"

    print("ğŸ”„ Checking for updates...")

    # Method 1: Prefer git if available
    if shutil.which("git") and (install_dir / ".git").exists():
        print("ğŸ“¦ Updating via git pull...")
        result = subprocess.run(
            ["git", "-C", str(install_dir), "pull", "--ff-only"],
            capture_output=True, text=True, encoding='utf-8', errors='replace'
        )
        if result.returncode == 0:
            print(result.stdout.strip() if result.stdout.strip() else "Already up to date.")
            print("ğŸ”§ Reinstalling...")
            subprocess.run([str(install_dir / "install.sh"), "install"])
            print("âœ… Update complete!")
            return 0
        else:
            print(f"âš ï¸ Git pull failed: {result.stderr.strip()}")
            print("Falling back to tarball download...")

    # Method 2: Download tarball
    tarball_url = f"{repo_url}/archive/refs/heads/main.tar.gz"
    tmp_dir = Path(tempfile.gettempdir()) / "ccb_update"

    try:
        print(f"ğŸ“¥ Downloading latest version...")
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir)
        tmp_dir.mkdir(parents=True, exist_ok=True)
        tarball_path = tmp_dir / "main.tar.gz"

        # ä¼˜å…ˆä½¿ç”¨ curl/wgetï¼ˆæ›´å¥½çš„è¯ä¹¦å¤„ç†ï¼‰
        downloaded = False
        if shutil.which("curl"):
            result = subprocess.run(
                ["curl", "-fsSL", "-o", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded and shutil.which("wget"):
            result = subprocess.run(
                ["wget", "-q", "-O", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded:
            # å›é€€åˆ° urllibï¼ˆå¯èƒ½æœ‰ SSL é—®é¢˜ï¼‰
            import ssl
            try:
                urllib.request.urlretrieve(tarball_url, tarball_path)
            except ssl.SSLError:
                print("âš ï¸ SSL è¯ä¹¦éªŒè¯å¤±è´¥ï¼Œå°è¯•è·³è¿‡éªŒè¯...")
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                with urllib.request.urlopen(tarball_url, context=ctx) as resp:
                    tarball_path.write_bytes(resp.read())

        print("ğŸ“‚ Extracting...")
        def _safe_extract(tar: tarfile.TarFile, dest: Path) -> None:
            dest = dest.resolve()
            for member in tar.getmembers():
                member_path = (dest / member.name).resolve()
                if not str(member_path).startswith(str(dest) + os.sep):
                    raise RuntimeError(f"Unsafe tar member path: {member.name}")
            tar.extractall(dest)

        with tarfile.open(tarball_path, "r:gz") as tar:
            _safe_extract(tar, tmp_dir)

        extracted_dir = tmp_dir / "claude_code_bridge-main"

        print("ğŸ”§ Installing...")
        env = os.environ.copy()
        env["CODEX_INSTALL_PREFIX"] = str(install_dir)
        subprocess.run([str(extracted_dir / "install.sh"), "install"], check=True, env=env)

        print("âœ… Update complete!")
        print("ğŸ’¡ æ¨èï¼šå®‰è£… WezTerm ä½œä¸ºç»ˆç«¯å‰ç«¯ï¼ˆåˆ†å±/æ»šåŠ¨ä½“éªŒæ›´å¥½ï¼‰ï¼Œè¯¦æƒ…è§ READMEã€‚")
        return 0

    except Exception as e:
        print(f"âŒ Update failed: {e}")
        return 1

    finally:
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(description="Claude AI ç»Ÿä¸€å¯åŠ¨å™¨", add_help=True)
    subparsers = parser.add_subparsers(dest="command", help="å­å‘½ä»¤")

    # up å­å‘½ä»¤
    up_parser = subparsers.add_parser("up", help="å¯åŠ¨ AI åç«¯")
    up_parser.add_argument("providers", nargs="*", choices=["codex", "gemini"], help="è¦å¯åŠ¨çš„åç«¯")
    up_parser.add_argument("-r", "--resume", action="store_true", help="æ¢å¤ä¸Šä¸‹æ–‡")
    up_parser.add_argument("-a", "--auto", action="store_true", help="å…¨è‡ªåŠ¨æƒé™æ¨¡å¼")
    up_parser.add_argument("--no-claude", action="store_true", help="ä¸å¯åŠ¨ Claude ä¸»çª—å£")

    # status å­å‘½ä»¤
    status_parser = subparsers.add_parser("status", help="æ£€æŸ¥çŠ¶æ€")
    status_parser.add_argument("providers", nargs="*", default=[], help="è¦æ£€æŸ¥çš„åç«¯ (codex/gemini)")

    # kill å­å‘½ä»¤
    kill_parser = subparsers.add_parser("kill", help="ç»ˆæ­¢ä¼šè¯")
    kill_parser.add_argument("providers", nargs="*", default=[], help="è¦ç»ˆæ­¢çš„åç«¯ (codex/gemini)")

    # restore å­å‘½ä»¤
    restore_parser = subparsers.add_parser("restore", help="æ¢å¤/attach ä¼šè¯")
    restore_parser.add_argument("providers", nargs="*", default=[], help="è¦æ¢å¤çš„åç«¯ (codex/gemini)")

    # update å­å‘½ä»¤
    update_parser = subparsers.add_parser("update", help="Update to latest version")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "status":
        return cmd_status(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "restore":
        return cmd_restore(args)
    elif args.command == "update":
        return cmd_update(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
